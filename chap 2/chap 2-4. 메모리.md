# 2-4 메모리
### 개요

프로그램은 메모리에 저장되며 CPU는 메모리의 정보를 읽고 쓰는 방식으로 동작

### RAM
- 메인 메모리는 주로 RAM(Random Access Memory)을 지칭
- RAM은 전원이 꺼지면 데이터가 사라지는 휘발성 저장장치
- CPU가 실행할 프로그램을 저장하는 부품으로, 보조기억장치에서 메모리로 프로그램을 복사해와야 실행 가능
- RAM 용량이 클수록 많은 데이터를 미리 저장할 수 있어 여러 프로그램 동시 실행에 유리

### RAM의 접근 방식과 종류

- **Random Access Memory**: 저장 요소에 순차적으로 접근할 필요 없이 임의 위치에 곧장 접근 가능 (직접 접근)
- 접근 위치에 관계없이 데이터 접근 시간이 동일하다는 특징
- 순차 접근(Sequential Access)과 반대되는 개념으로, 순차 접근은 처음부터 순서대로 접근하는 것을 말함

### RAM의 종류

1. **DRAM (Dynamic RAM)**: 시간이 지나면 데이터가 점차 사라지므로 일정 주기로 재활성화 필요. 전력 소비가 낮고 저렴하며 집적도가 높아 대용량 설계에 용이
2. **SRAM (Static RAM)**: 시간이 지나도 데이터가 사라지지 않음 (단, 전원 공급 중단 시 소멸). DRAM보다 빠르지만 전력 소비가 크고 가격이 비싸며 집적도가 낮음. 캐시 메모리 같은 고속 저장장치에 사용
3. **SDRAM (Synchronous Dynamic RAM)**: 클럭 신호와 동기화된 발전된 형태의 DRAM. 클럭 타이밍에 맞춰 CPU와 정보 주고받기 가능
4. **DDR SDRAM (Double Data Rate SDRAM)**: 대역폭을 높여 SDRAM보다 빠르게 만든 버전. 한 클럭당 2번씩 CPU와 데이터 주고받기 가능 (SDRAM의 2배 전송 속도)
  - DDR2, DDR3, DDR4 등으로 발전하며 대역폭이 계속 증가 (DDR4는 SDRAM 대비 16배 넓은 대역폭)

### 바이트 저장 순서 (Endian)

- 메모리는 데이터를 **바이트** 단위로 저장하지만 CPU로부터는 Word 단위(4바이트 또는 8바이트)로 받아들임
- 여러 바이트로 구성된 데이터를 여러 주소에 걸쳐 저장
  - 한주소에 1바이트씩 저장하는 메모리는 4바이트(32bit)의 데이터를 4개의 주소에 저장
  - 16진수(4bit*2개)인 1A2B3C4D가 4개의 주소에 나뉘어 저장 
- **빅 엔디안 (Big-endian)**: 낮은 번지 주소에 상위 바이트(큰 값)부터 저장. 일상적인 숫자 체계와 동일하여 디버깅 시 편리
- **리틀 엔디안 (Little-endian)**: 낮은 번지 주소에 하위 바이트(작은 값)부터 저장. 메모리 값을 직접 읽기는 불편하지만 수치 계산에 유리

#### MSB와 LSB

- **MSB (Most Significant Bit)**: 숫자 크기에 가장 큰 영향을 미치는 유효 숫자 (가장 왼쪽 비트)
- **LSB (Least Significant Bit)**: 숫자 크기에 가장 적은 영향을 미치는 유효 숫자 (가장 오른쪽 비트)
- 빅 엔디안은 MSB가 있는 바이트부터, 리틀 엔디안은 LSB가 있는 바이트부터 저장

### 캐시 메모리

- CPU 연산 속도와 메모리 접근 속도 차이를 줄이기 위해 탄생한 SRAM 기반 저장장치
- CPU가 사용할 법한 데이터를 미리 가져와 저장
- **캐시 레벨**: L1 (코어와 가장 가까움) → L2 → L3 (코어와 가장 먼) 순으로 위치
  - 일반적으로 L1, L2는 코어 내부에, L3는 코어 외부에 위치
  - 메모리 크기: L1 < L2 < L3 순으로 증가
  - 속도: L1 > L2 > L3 순으로 빠름
  - 멀티코어 시스템에서 L1, L2는 코어마다 독립적으로 할당되고 L3는 여러 코어가 공유
- **분리형 캐시**: 명령어만 저장하는 L1I 캐시와 데이터만 저장하는 L1D 캐시로 구분

### 캐시 히트와 캐시 미스

- **캐시 히트**: 캐시 메모리가 예측한 데이터를 CPU가 실제로 사용하는 경우
- **캐시 미스**: 예측이 틀려 CPU가 메모리부터 직접 데이터를 가져와야 하는 경우. 캐시 메모리의 이점 활용 불가
- **캐시 적중률**: 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)
- 일반적으로 사용되는 캐시의 적중률은 약 85~95% 이상

### 참조 지역성의 원리

캐시 적중률을 높이기 위해 캐시 메모리가 따르는 원칙: 

- **시간 지역성 (Temporal Locality)**: CPU가 최근 접근한 메모리 공간에 다시 접근하려는 경향. 프로그래밍 언어의 변수가 대표적 사례 (변수는 실행 중 여러 번 사용됨)
- **공간 지역성 (Spatial Locality)**: CPU가 접근한 메모리 공간 근처에 접근하려는 경향. 배열이 대표적 사례
  - 이중 반복문에서 배열 접근 시 `matrix[i][j]`가 `matrix[j][i]`보다 빠른 이유는 공간 지역성 때문
  - 한 행의 모든 열을 순회하는 방식이 캐시 효율적

### 캐시 쓰기 정책과 일관성

새로 쓰여진 데이터와 **메모리상의 데이터 간 일관성 유지**가 중요  

**쓰기 정책**:

- **즉시 쓰기 (Write-through)**: 캐시 메모리와 메모리에 동시에 쓰기. 항상 최신 상태 유지로 일관성 보장하지만 메모리 접근이 잦아 버스 사용시간과 쓰기 시간 증가
- **지연 쓰기 (Write-back)**: 캐시 메모리에만 쓰고 나중에 메모리에 반영. 메모리 접근 횟수가 적어 속도는 빠르지만 일관성이 깨질 위험 존재

**일관성 문제**:

- 캐시 메모리와 메모리 간 불일치뿐만 아니라 다른 코어의 캐시 메모리와의 불일치도 발생 가능
- 캐시 일관성 프로토콜(Cache Coherence Protocol)로 해결
- 캐싱은 빠른 성능을 보장하지만 데이터 일관성 유지에 대한 책임이 따름

### 캐시 일관성 프로토콜 - MESI
- 캐시 변경사항이 생기면 다른 캐시들에 변경사항을 브로드캐스트, 다른 캐시들은 그 메시지를 받아서 자기들의 데이터를 최신 상태로 맞추는 것
- 즉, **코어가 **버스(Bus)를 감시(Snooping)**하며 서로의 상태 변화를 체크하는 것**


#### 💡 MESI 동작 시나리오 (Step-by-Step)

코어 A와 코어 B가 동일한 메모리 주소 를 사용하는 상황

1. 코어 A가 를 처음으로 읽을 때 (Read Miss)
    * **동작:** 코어 A가 메모리에서 를 가져옵니다.
    * **결과:** 다른 코어에 가 없으므로, 코어 A는 **E (Exclusive)** 상태가 됩니다.
    * **의미:** "나만 이 데이터를 가지고 있고, 아직 수정은 안 했어."
2. 코어 B가 를 읽을 때 (Read Hit/Miss)
    * **동작:** 코어 B가 버스에 읽기 요청을 보냅니다. 코어 A가 이를 감지(Snooping)합니다.
    * **결과:** 코어 A와 코어 B 모두 **S (Shared)** 상태로 변경됩니다.
    * **의미:** "우리 둘 다 같은 데이터를 가지고 있고, 메모리와 내용이 같아."
3. 코어 A가 를 수정할 때 (Write Hit)
    * **동작:** 코어 A가 데이터를 수정하기 전, 버스에 **"나 이거 수정할 거야(Invalidate 신호)"**라고 알립니다.
    * **결과:** * 코어 A: **M (Modified)** 상태로 변경 (메모리보다 최신 데이터 보유).
    * 코어 B: 코어 A의 신호를 듣고 자신의 데이터를 **I (Invalid)** 상태로 바꿉니다.
    * **의미:** "이제 내가 가진 게 유일한 진짜고, 다른 애들 건 다 가짜(무효)야."
4. 코어 B가 다시 를 읽으려 할 때 (Read Miss)
    * **동작:** 코어 B는 자기 데이터가 **I** 상태이므로 다시 읽기 요청을 보냅니다.
    * **결과:** * **M** 상태였던 코어 A가 이를 가로채서(Snooping) 최신 데이터를 버스에 흘려줍니다.
    * 이 과정에서 코어 A의 데이터가 메모리에 기록(Write-back)됩니다.
    * 결국 다시 둘 다 **S (Shared)** 상태가 됩니다.



#### 상태 전이 요약표
| 현재 상태 | 이벤트 | 다음 상태 | 비고 |
| --- | --- | --- | --- |
| **I (Invalid)** | 읽기 (Read) | **E** 또는 **S** | 다른 코어 보유 여부에 따라 결정 |
| **E (Exclusive)** | 읽기 (Read) | **E** | 변화 없음 |
| **E (Exclusive)** | 쓰기 (Write) | **M** | 버스에 알릴 필요 없이 바로 수정 가능 |
| **S (Shared)** | 쓰기 (Write) | **M** | 다른 코어에 **Invalidate 신호**를 보냄 |
| **M (Modified)** | 타인의 읽기 | **S** | 내 데이터를 공유하고 메모리에 업데이트함 |
