# 2-3 CPU
### 레지스터 (Registers)

- CPU 내부의 임시 저장장치로 다양한 종류와 역할 존재
- 프로그램 실행 전후 데이터와 명령어가 레지스터에 저장되어 프로그램 작동 파악 가능

**주요 레지스터 종류:**

1. **프로그램 카운터 (Program Counter)**: 다음 명령어 주소 저장, 명령어 포인터라고도 불림. 순차적 실행을 위해 일반적으로 증가하지만 조건문/리턴문 등에서는 임의 위치로 변경 가능 
2. **명령어 레지스터 (Instruction Register)**: 메모리에서 읽어들인 명령어 저장. 제어장치가 명령어를 해석하고 ALU에 연산 지시 또는 제어 신호 전송  
3. **범용 레지스터 (General Purpose Registers)**: 다양한 상황에서 자유롭게 사용 가능. 데이터와 명령어 주소 모두 저장 가능하며 CPU 내 여러 개 존재 
4. **플래그 레지스터 (Flag Register)**: 연산 결과나 CPU 상태 정보(플래그 값) 저장 
    - 종류: 부호 플래그, 제로 플래그, 캐리 플래그, 오버플로우 플래그, 인터럽트 플래그, 슈퍼바이저 플래그 등
    - 예: 부호 플래그=1이면 연산 결과가 음수, 제로 플래그=1이면 결과가 0
5. **스택 포인터 (Stack Pointer)**: 메모리 스택 영역의 최상단 데이터 위치 가리킴. 스택 채워진 정도를 나타내는 레지스터  

### 인터럽트 (Interrupts)

- CPU 작업을 방해하는 신호로 다양한 상황에서 발생

**인터럽트 종류:**

1. **동기 인터럽트 (예외, Exception)**: CPU에 의해 발생하는 인터럽트. 프로그래밍 오류 등 예외 상황 시 발생 
2. **비동기 인터럽트 (하드웨어 인터럽트)**: 입출력 장치에 의해 발생하는 인터럽트  
    - 예: 프린터 작업 완료 알림, 키보드/마우스 입력 알림

**하드웨어 인터럽트의 효율성:**

- 폴링(polling) 방식 대비 CPU 사이클 낭비 최소화
- 폴링: 입출력 장치 상태를 주기적으로 확인하는 비효율적 방식

**인터럽트 처리 순서:**

<img width="585" height="462" alt="스크린샷 2025-12-16 오후 5 30 34" src="https://github.com/user-attachments/assets/6e00c72c-1946-4b6a-8834-f62ed24e05c6" />

1. 입출력 장치가 CPU에 인터럽트 요청 신호 전송 
2. CPU는 실행 사이클 종료 후 인터럽트 여부 확인
3. 인터럽트 플래그로 수용 가능 여부 확인
4. 수용 가능하면 작업 백업
5. 인터럽트 벡터 참조하여 인터럽트 서비스 루틴 실행
6. 루틴 종료 후 백업 작업 복구 및 실행 재개

**주요 개념:**

- **인터럽트 요청 신호**: CPU에 인터럽트 가능 여부 확인하는 신호
- **인터럽트 플래그**: 하드웨어 인터럽트 수용/무시 결정. 단, 최우선순위 인터럽트(정전, 하드웨어 고장)는 플래그 무시하고 처리
- **인터럽트 서비스 루틴 (ISR)**: 인터럽트 처리 프로그램, 인터럽트 핸들러라고도 불림
- **인터럽트 벡터**: 인터럽트 서비스 루틴 식별 정보. 서비스 루틴의 시작 주소를 찾는데 사용

**인터럽트 실행 과정:**

<img width="500" height="462" alt="스크린샷 2025-12-16 오후 5 30 01" src="https://github.com/user-attachments/assets/a0562724-1cb3-466e-ba69-533032f52d28" />

- ISR도 프로그램처럼 레지스터 사용하며 실행
- 현재 작업은 메모리 스택에 백업
- 프로그램 카운터를 ISR 시작 주소로 갱신하여 실행
- 실행 완료 후 스택에서 프로그램 카운터 복구하여 작업 재개

#### 명령어 사이클

<img width="400" alt="스크린샷 2025-12-16 오후 5 27 39" src="https://github.com/user-attachments/assets/ca321dd9-589c-4d3e-90d1-34ebcf050345" />


### 예외 (Exceptions)

**예외 종류:**

1. **폴트 (Fault)**: 예외 처리 후 예외 발생 명령어부터 실행 재개  
    - 예: 필요한 데이터가 보조기억장치에 있어 메모리로 가져온 후 해당 명령어부터 재실행
2. **트랩 (Trap)**: 예외 처리 후 다음 명령어부터 실행 재개
    - 예: 디버깅 브레이크포인트
3. **중단 (Abort)**: 실행 중 프로그램을 강제 종료해야 하는 심각한 오류 
4. **소프트웨어 인터럽트**: 시스템 콜 발생 시 발생하는 예외 

### CPU 성능 향상

**클럭 속도 (Clock Speed):**

- 클럭: 컴퓨터 부품을 일사불란하게 움직이는 시간 단위
- 클럭 주기에 맞춰 데이터 이동, ALU 연산, 명령어 인출 수행
- 헤르츠(Hz) 단위 측정 (현재 일반적으로 기가헤르츠 사용)
- 클럭 속도 높을수록 성능 향상되지만 발열 문제로 한계 존재

**멀티코어 & 멀티스레드:**

- **코어 (Core)**: CPU 내 명령어를 읽고 해석하고 실행하는 부품
- **멀티코어 CPU**: 여러 개의 코어 포함하는 CPU
- **하드웨어 스레드**: 하나의 코어가 동시에 처리하는 명령어 단위
    - 예: 2코어 4스레드 = 2개 부품이 4개 명령 동시 처리
    - 논리 프로세서라고도 불림
- **소프트웨어 스레드**: 프로그램에서 독립적으로 실행되는 단위
- 하드웨어 스레드는 **병렬성**(물리적 동시 처리), 소프트웨어 스레드는 **동시성**(동시 처리처럼 보임) 구현

### 명령어 병렬 처리

**명령어 파이프라이닝:**

<img width="450" height="342" alt="스크린샷 2025-12-16 오후 5 33 07" src="https://github.com/user-attachments/assets/2c762f4e-4173-4467-8dd6-6afa664b6bac" />

- 명령어 처리 과정을 단계별로 분할: 인출 → 해석 → 실행 → 저장
- 같은 단계가 겹치지 않으면 각 단계를 동시 실행 가능
- 공장 생산라인처럼 명령어를 동시 처리하는 기법

**슈퍼스칼라 (Superscalar):**

- CPU 내부에 여러 명령어 파이프라인 포함하는 구조
- 생산라인을 여러 개 두는 것과 동일한 개념

**CISC vs RISC:**

- **CISC (Complex Instruction Set Computer)**:
    - 복잡하고 다채로운 기능의 명령어 집합
    - 적은 수의 명령어로 프로그램 실행 가능
    - 명령어 크기와 실행 시간 불규칙하여 파이프라이닝 비효율적
    - 예: Intel CPU
- **RISC (Reduced Instruction Set Computer)**:
    - 짧고 규격화된 명령어, 1클럭 내외 실행 지향
    - CISC보다 많은 명령어 필요하지만 파이프라이닝에 최적화
    - 예: Apple M1 CPU

**파이프라인 위험 (Pipeline Hazards):**

1. **데이터 위험**: 명령어 간 데이터 의존성으로 동시 처리 불가  
2. **제어 위험**: 프로그램 카운터의 갑작스러운 변화(점프, 인터럽트)로 미리 인출한 명령어가 무용지물됨 
3. **구조적 위험**: 서로 다른 명령어가 동시에 ALU, 레지스터 등 CPU 부품 사용 시도 시 발생
