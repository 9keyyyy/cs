# 3-2 프로세스와 스레드

### 프로세스
- 메모리에는 컴퓨터가 실행되는 순간부터 다양한 프로세스들이 적재되어 실행
- 프로세스의 유형
  - **포그라운드 프로세스**: 사용자가 보는 공간에서 사용자와 상호작용하며 실행
  - **백그라운드 프로세스**: 사용자가 보지 못하는 곳에서 실행
    - **데몬**: 백그라운드 프로세스 중 사용자와 별다른 상호작용 없이 주어진 작업만 수행하는 프로세스 (윈도우에서는 **서비스**라고 부름)

</br>

### 하나의 프로세스를 구성하는 메모리 내 정보

<img width="500" alt="스크린샷 2026-01-20 오후 11 29 39" src="https://github.com/user-attachments/assets/557af9a5-4d9d-43d1-a5e5-7d3f803e55e7" />

- **커널 영역**에는 프로세스 제어 블록(**PCB**) 정보가 저장
- **사용자 영역**에는 실행 중인 프로세스가 **코드 영역, 데이터 영역, 힙 영역, 스택 영역**으로 나뉘어 저장
  - 코드 영역: 실행 가능한 명령어가 저장. CPU가 읽고 실행할 명령어가 담겨 있기 때문에 쓰기는 금지되어 있는 공간
  - 데이터 영역: 프로그램이 실행되는 동안 유지할 데이터 저장 (**정적 변수, 전역 변수**)
  - 힙 영역: 개발자가 직접 할당 가능한 저장 공간. 할당 후 반환하지 않으면 **메모리 누수** 발생 가능. 자체적으로 사용되지 않는 메모리 해제하는 **가비지 컬렉션** 존재하기도 함
  - 스택 영역: 일시적으로 사용할 값들이 저장되는 공간. 함수의 실행이 끝나면 사라지는 **매개변수, 지역 변수, 함수 복귀 주소** 등
    - **스택 트레이스** 형태로 함수 호출 정보 저장될 수 있음 → 문제 발생 지점을 추적할 수 있어 디버깅에 유용 
- 코드, 데이터 영역은 프로그램 실행 도중 크기가 변하지 않기 때문에 정적 할당 영역, 힙과 스택 영역은 크기가 변할 수 있으므로 동적 할당 영역

</br>

### PCB와 문맥 교환

#### PCB란?
- 운영체제가 메모리에 적재된 다수의 프로세스를 관리하기 위해 **프로세스를 식별**할 수 있는 **커널 영역 내**의 정보
- 프로세스와 관련된 다양한 정보를 내포하는 구조체의 일종
- 새로운 프로세스가 메모리에 적재되면 커널 영역에 만들어지고, 실행이 끝나면 폐기
- 커널 내 **프로세스 테이블**의 형태로 관리되는 경우가 많음 (비정상 종료로 자원이 회수되었지만 PCB가 남아있는 경우 좀비 프로세스로 남음)

#### PCB에 담기는 정보
- 프로세스 ID
- 실행 과정에서 사용한 레지스터 값
- 프로세스 상태
- CPU 스케줄링(우선순위) 정보
- 메모리 관련 정보 (메모리상 프로세스의 적재 위치 확인)
- 파일 및 입출력 장치 관련 정보

#### 문맥 교환
- CPU는 프로세스를 구성하는 명령어/데이터를 인출하여 실행, 운영체제는 CPU 자원을 할당
  > 프로세스가 실행된다 = 운영체제에 의해 CPU의 자원을 할당 받았다 </br>
  > 즉, 다양한 프로세스들이 한정된 시간 동안 번갈아 실행한다 = 다양한 프로세스들이 한정된 시간동안 운영체제로부터 CPU 자원을 번갈아 할당받아 이용한다
- **타이머 인터럽트**: 프로세스의 CPU 사용 시간을 제한하는 인터럽트. 발생 시 자신의 차례를 양보하고 다음 차례를 기다림 
  - 프로세스 A → B로 변경되는 경우, A는 지금까지의 중간 정보를 **백업**해야 함 (차례가 되면 이어할 수 있도록)
  - 이때, 프로세스의 수행을 재개하기 위해 기억해야할 정보를 **문맥**(context)이라고 함
- **문맥 교환**: 운영체제가 인터럽트가 발생하면 **해당 프로세스의 PCB에 문맥을 백업** → 뒤이어 **실행할 프로세스의 문맥을 복구**
  <img width="400" alt="스크린샷 2026-01-20 오후 11 55 56" src="https://github.com/user-attachments/assets/d65b4f76-62ee-4fe7-952e-19d838ed7b82" />
  - 문맥 교환이 자주 발생하면 캐시 미스 발생 가능성이 높아지고, 큰 오버헤드로 이어질 수 있음

### 프로세스의 상태

<img width="569" height="306" alt="스크린샷 2026-01-28 오후 8 25 14" src="https://github.com/user-attachments/assets/070b68a0-0e76-40b8-b0e9-4088f6c35d87" />

- **생성** 상태
  - 프로세스를 생성 중
  - 메모리에 적재되어 PCB 할당 받은 상태 (CPU 할당을 기다림)
- **준비** 상태
  - 당장 CPU를 할당받아 실행할 수 있지만, 차례를 기다리고 있는 상태
  - 준비 상태인 프로세스가 실행 상태로 전환되는 것을 **디스패치**라고 함
- **실행** 상태
  - CPU를 할당받아 실행 중인 상태 (일정 시간만 사용 가능)
  - 타이머 인터럽트 발생으로 할당 시간 모두 소진 시 다시 **준비** 상태로 되돌아감
- **대기** 상태
  - 프로세스가 곧장 실행이 불가능한 조건에 놓이는 경우 (입출력 작업 혹은 바로 확보 불가한 자원을 요청)
  - 작업을 완료하여 실행 가능 상태가 되면 다시 준비 상태가 되어 CPU 할당을 대기
- **종료** 상태
  - 프로세스가 종료된 상태
  - 프로세스가 종료되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리
 
#### 블록킹 입출력과 논블로킹 입출력
- 블로킹 입출력: 실행 도중 입출력 작업 수행을 위해 대기 상태로 접어들고, 작업 완료 시 준비 상태가 되어 실행을 재개 하는 것
- 논블로킹 입출력: 입출력장치에게 작업을 맡긴 뒤, 곧바로 이어질 명령어를 실행하는 것

## 멀티프로세스와 멀티스레드
- 멀티프로세스
  - 동시에 여러 프로세스가 실행되는 것
  - 각기 다른 프로세스들은 기본적으로 자원을 공유하지 않고 독립적으로 실행 (자원이 독립적으로 할당되어 다른 프로세스에 영향 거의 X)
  - 예시) 웹 브라우저의 탭 
- 멀티스레드
  - 프로세스를 동시에 실행하는 여러 스레드
  - 스레드 ID와 프로그램 카운터, 레지스터 값, 스택 등으로 구성되며, 스레드마다 각각 프로그램 카운터 값과 스택을 가지고 있음
- 멀티프로세스와  
