# 2-5 보조기억장치와 입출력 장치
## 보조기억장치
- 대중적으로 활용되는 보조기억장치: 하드 디스크 드라이브, 플래시 메모리 기반 저장장치
- 하드 디스크
  - 자기적 방식으로 데이터 읽고 씀
  - 플래터(동그란 원판), 헤드(리더)
- 플래시 메모리
  - 전기적 방식으로 데이터 읽고 씀
  - USB 메모리, SD 카드, **SSD**
- 보조 기억 장치의 본분
  - **전원이 꺼져도 데이터 안전**하게 보관
  - CPU가 필요로 하는 정보를 조금이라도 빠른 성능으로 메모리에 전달
 
### RAID
- 데이터의 **안전 혹은 성능을 확보**하기 위해 여러 개의 독립적인 보조기억장치를 마치 **하나의 보조기억장치**처럼 사용
- 구성 방법(RAID 레벨): RAID0 ~ RAID6

### RAID0

<img width="600" alt="스크린샷 2025-12-21 오후 6 43 11" src="https://github.com/user-attachments/assets/97eb6438-4693-44fa-896e-7c8b69999be0" />

- 데이터를 여러 보조기억장치에 단순하게 나누어 저장하는 구성 방식
- 줄무늬처럼 분산되어 저장된 데이터를 **스트라입**이라고 하고, 이렇게 분산하여 저장하는 동작을 **스트라이핑**이라 함
- 장점
  - 빠른 입출력 속도: 데이텉를 한번에, 동시에 읽고 쓸 수 있기 때문
  - ex. A1 ~ A4 동시에 읽어들이면 하드디스크 1~4 동시에, 한번에 읽을 수 있음
- 단점
  - 저장된 정보가 안전하지 않음
  - ex. 하드디스크1에 문제가 생기면 하드디스크2, 3, 4에 저장된 데이터는 불완전 데이터
 
### RAID1

<img width="600"  alt="스크린샷 2025-12-21 오후 6 48 40" src="https://github.com/user-attachments/assets/9fa16187-1387-4f36-bfdf-35e564f8524e" />

- 완전한 복사본을 만들어 저장하는 구성 방식 (미러링)
- 장점
  - 복구가 간단하고 안전성이 높음
- 단점
  - 데이터를 쓸 때 원본과 복사본 두곳에 써야하기 때문에 RAID0 보다 쓰기 속도가 느림
  - 복사본이 저장된 크기만큼 사용가능한 용량이 적어짐

### RAID4

<img width="600" alt="스크린샷 2025-12-21 오후 6 52 12" src="https://github.com/user-attachments/assets/9cb67fd3-3a61-4401-9aa8-74f2f0c4577e" />

 
- 패리티 정보를 저장하는 디스크를 따로 두는 구성 방식
 - 패리티: 오류를 검출할 수 있는 정보
- 장점
  - RAID1에 비해 적은 하드디스크로도 안전하게 데이터 보관 가능
- 단점
  - 패리티를 저장하는 장치에 병목 현상 발생 (새로운 데이터가 저장될 때마다 패리티 저장 디스크에도 데이터를 쓰게 됨)
  - ex. 하드디스크4가 병목 지점이 될 수 있음

 ### RAID5
 
<img width="600" alt="스크린샷 2025-12-21 오후 6 53 20" src="https://github.com/user-attachments/assets/9fc1dc62-6275-4013-8207-533ab1fa28aa" />

- 패리티를 분산하여 저장하는 구성 방식
- RAID4의 단점인 병목 현상 보완

### RAID6

<img width="600" alt="스크린샷 2025-12-21 오후 6 55 10" src="https://github.com/user-attachments/assets/22e23761-b4df-4f03-8b1c-96b6a15be4f2" />

- 구성은 RAID5와 같지만, 서로 다른 2개의 패리티를 두는 구성방식
- 오류를 검출하고 복구할 수 있는 수단이 2개
- RAID4, 5에 비해 안정성은 높지만, 새로운 정보를 저장할 때마다 저장해야할 패리티가 2개이므로 속도는 더 느림

#### Nested RAID?
RAID 레벨을 혼합한 방식

## 입출력 기법
- 보조기억장치는 결국 메모리를 보조하는 임무를 수행하는 특별한 입출력장치

### 장치 컨트롤러와 장치 드라이버
- CPU 입장에서 모든 입출력장치의 작동 방식을 아는 것은 어려움
- **장치 컨트롤러**
  - 입출력장치는 CPU와 직접 연결 X -> **장치 컨트롤러**라는 하드웨어 통해 연결
  - CPU와 입출력장치 사이의 통신을 중개하는 중개자 역할의 하드웨어
  - ex. CPU가 직접 하드디스크 회전 or 마이크 입력값 해석 X -> 장치 컨트롤러의 중개 필요
- **장치 드라이버**
  - CPU가 실행하는 것은 프로그램, CPU는 장치 컨트롤러와 상호작용하며 입출력장치 작동
    - 이는 CPU가 실행하는 프로그램을 통해 이루어진다는 말과 같음 -> 이 프로그램이 **장치 드라이버**
  - 일반적으로 장치 컨트롤러마다 이를 작동시키는 장치 드라이버가 있음
  - 장치 드라이버는 장치 컨트롤러의 동작을 알고, 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있도록 하는 프로그램

### 프로그램 기반 입출력
- 프로그램 속 명령어로 입출력 작업을 수행하는 방법
  - CPU는 입출력 명령어를 실행함으로써 장치 컨트롤러와 상호작용 가능
- 입출력 방식
  - 입출력 명령어의 오퍼랜드를 식별하는 방식에 따라 고립형 입출력, 메모리 맵 입출력으로 나뉨
  - 고립형 입출력: 입출력장치에 접근하는 주소와 메모리에 접근하는 주소를 별도의 주소 공간으로 간주
  - 매모리 맵 입출력: 입출력장치에 접근하는 주소 공간과 메모리에 접근하는 주소 공간을 구분하지 않음

### 인터럽트 기반 입출력: 다중 인터럽트 (인터럽트가 여러 입출력장치로부터 동시다발적으로 발생하는 경우)
- CPU가 플래그 레지스터 속 인터럽트 비트를 비활성화한 채 인터럽트를 처리할 경우, 다른 하드웨어 인터럽트를 받아들이지 않음
- 하지만, 인터럽트 중 우선순위가 더 높은 인터럽트가 우선적으로 처리되는 것이 일반적
- CPU는 아래 경우 우선순위가 높은 인터럽트부터 먼저 처리
  - 플래그 레지스터 속 인터럽트 비트가 활성화되어 있는 경우
  - 인터럽트 비트를 비활성화해도 무시할수 없는 인터럽트인 NMI가 발생한 경우

### PIC
- 다중 인터럽트를 처리하기 위해서는 **프로그래머블 인터럽트 컨트롤러(PIC)**라는 하드웨어 사용
  - 여러 장치 컨트롤러에 연결 -> 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위 판별 -> CPU에 지금 처리해야할 인터럽트가 무엇인지 알려줌
- 일반적으로 PIC는 많은 하드웨어 인터럽트를 관리하기 위해 2개 이상의 계층으로 구성

### DMA(Direct Memory Access) 입출력
- 프로그램 기반 입출력, 인터럽트 기반 입출력 공통점:
  - **CPU가 입출력장치와 메모리 간의 데이터 이동을 주도 + 이동하는 데이터들도 반드시 CPU 거침**
  - ex. 입출력장치의 데이터를 메모리에 저장하는 경우, CPU는 장치 컨트롤러로부터 데이터 읽어 레지스터에 적재 -> 적재한 데이터 메모리에 저장
- 입출력장치 - 메모리 사이 모든 데이터 전송이 CPU를 거쳐야한다면 CPU의 부담이 커짐 -> DMA 등장
- DMA는 **직접 메모리에 접근**할 수 있는 입출력 기능
  - 시스템 버스에 연결된 **DMA 컨트롤러**라는 하드웨어 필요
  - DMA 컨트롤러는 시스템 버스에 연결, 입출력장치들의 장치 컨트롤러들은 **입출력 버스**라는 입출력장치 컨트롤러의 전용 버스와 연결
    <img width="600" height="454" alt="스크린샷 2025-12-21 오후 7 20 04" src="https://github.com/user-attachments/assets/0223352c-b878-41c7-9d26-2782dc948b76" />









  
