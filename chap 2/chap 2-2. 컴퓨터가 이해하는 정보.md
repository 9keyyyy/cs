# 2-2 컴퓨터가 이해하는 정보
- 컴퓨터는 0과 1만 이해하는 이진법 시스템
- 정보의 가장 작은 단위는 비트(bit)이며, 비트가 추가될 때마다 표현 가능한 정보량은 2의 지수 형태로 증가
- 8비트 = 1바이트 = 256가지(2^8) 정보 표현 가능
- 단위: 바이트 → 킬로바이트 → 메가바이트 → 기가바이트 → 테라바이트

### 데이터 표현 단위

- 워드(word): CPU가 한 번에 처리할 수 있는 데이터 크기
- CPU가 16비트 처리 가능하면 1워드=16비트, 32비트 처리 가능하면 1워드=32비트
- 16진법은 숫자가 길어지는 2진법의 단점을 보완하며, 10-15는 A-F로 표기

### 실수(소수) 표현 방식

- 파이썬에서 0.1+0.2≠0.3으로 나오는 이유는 부동소수점 방식의 정밀도 한계 때문
- 십진수 표현: m × 10^n (m=가수, n=지수)
- 이진수 표현: m × 2^n
- IEEE754 표준 부동소수점 형식:
    - 첫 번째 비트는 부호(0=양수, 1=음수)
    - 32비트 방식: 지수 8비트, 가수 23비트
    - 64비트 방식: 지수 11비트, 가수 52비트
- 정규화된 수는 1.xxx × 2^n 형태로 저장
- 지수에는 바이어스 값이 더해짐
    - 바이어스 값: 2^(k-1)-1  (k는 지수의 비트 수)
    - 32비트는 127, 64비트는 1023
    - 바이어스를 더하는 이유는 음수 지수를 양수 형태로 저장하기 위함

### 부동소수점 오차와 문자 표현

- 10진수 소수와 2진수 소수 표현은 정확히 일치하지 않을 수 있음
- 일부 10진수는 2진수로 변환할 때 무한히 많은 소수점이 필요하므로 일부 생략하여 오차 발생 ([참고](https://gemini.google.com/share/7e10c677340c))
- 이러한 이유로 0.1+0.2≠0.3 현상 발생

### 데이터: 0과 1로 문자 표현하기

- **문자 집합**: 컴퓨터가 이해할 수 있는 문자들의 집합
- **문자 인코딩**: 문자를 0과 1로 변환하는 과정
- **문자 디코딩**: 0과 1을 사람이 이해하는 문자로 변환하는 과정
- 웹사이트에서 글자가 깨지는 현상은 인코딩/디코딩 방식 불일치 때문

### ASCII 문자 인코딩

- 영어 알파벳, 아라비아 숫자, 특수문자를 포함하는 초창기 문자 집합
- 1바이트(8비트) 사용: 1비트는 **패리티 비트**(오류 검출용), 7비트가 실제 문자 표현에 사용됨
- 총 128개(2^7)의 문자 표현 가능
- 각 문자는 0~127 사이의 고유한 숫자(ASCII 코드)에 대응됨
  - 예시: 대문자 'A'는 십진수 65, 이진수 1000001로 인코딩
- 문자에 부여된 고유한 값을 **코드 포인트**라고 함 (예: 'A'의 코드 포인트는 65)

### 한글 인코딩 (EUC-KR)

- ASCII로는 한글 표현 불가능하여 등장
- ASCII 문자는 1바이트, 한글 글자는 2바이트로 표현
  - 2바이트는 4자리 16진수로 표현 가능
- 약 2,350개의 한글 단어 표현 가능하나, 모든 한글 조합을 표현하기에는 부족

### 유니코드 (Unicode)

- 한글을 포함한 다양한 언어, 특수문자, 이모티콘까지 표현 가능한 통일된 문자 집합
- 국가별로 다른 문자 집합이나 인코딩 방식을 준비할 필요가 없어짐
- **현대에서 가장 많이 사용**되는 표준 문자 집합
- UTF-8, UTF-32 등은 **유니코드 문자를 인코딩하는 방식**
  - **가변 길이 인코딩** 방식으로 인코딩 결과의 길이가 일정하지 않을 수 있음

### Base64 인코딩

- 문자뿐만 아니라 이진 데이터까지 변환 가능한 인코딩 방식
- 이미지 등 단순 문자 이외의 데이터를 ASCII 문자 형태로 표현
  - 이진 데이터를 64개의 안전한 ASCII 문자로 변환하여 JSON, HTML 같은 텍스트 전송 형식에서 사용 용이
- 64진법 사용: 6비트(2^6)로 하나의 Base64 문자 표현
  - 기본적으로 24비트(4개 문자)씩 변환
    - 인코딩 예시: "abc" → ASCII 코드 97, 98, 99 → 이진수 변환 후 6비트씩 분할 → "YWJj"
  - 6비트로 나누어떨어지지 않는 경우 '=' 기호로 **패딩** 처리

### 명령어의 구조

- 명령어는 연산코드(opcode)와 오퍼랜드(operand)로 구성
- **연산코드**: **수행할 동작**을 나타냄 (연산자)
  - 연산코드 필드: 연산코드가 담기는 영역
  - 연산코드 유형: 데이터 전송, 산술 논리 연산, 제어 흐름 변경, 입출력 제어 등
- **오퍼랜드**: **수행할 대상**. 즉, 동작에 사용될 데이터 또는 데이터가 저장된 위치 (피연산자)
  - 오퍼랜드 필드 (**주소 필드**): 오퍼랜드가 담기는 영역, 주로 메모리 주소나 레지스터 이름이 명시됨
  - 오퍼랜드에 메모리 주소가 명시된 경우 추가 메모리 접근 필요

### 기계어와 어셈블리어

- **기계어**: CPU가 이해할 수 있도록 0과 1로 표현된 정보
  - 소스코드는 컴퓨터 내부에서 기계어로 변환되어 실행
- **어셈블리어**: 기계어를 읽기 편한 형태로 변환한 언어
  - 어셈블리어의 각 줄은 CPU가 읽고 해석하고 실행하는 명령어
- 명령어의 종류와 형태는 CPU에 따라 다름
  - 같은 소스코드도 CPU 종류에 따라 다른 어셈블리어로 표현됨
  - CPU마다 이해하는 명령어가 다르면 프로그램 실행 불가
  - 예: 인텔 CPU용 실행 파일을 애플 CPU에서 그대로 실행 불가
- 여러 플랫폼에서 실행하는 프로그램 개발 시 특정 CPU에만 의존적인 코드 지양 필요

### 명령어 사이클

- CPU가 명령어를 처리하는 과정은 정형화된 흐름을 따름
- 명령어 사이클: 명령어가 일정한 주기를 반복하면서 실행되는 과정
  - 인출 사이클: 메모리에서 명령어를 CPU로 가져오는 단계
  - 실행 사이클: CPU로 가져온 명령어를 실행하는 단계
    - 인출과 실행 사이클은 반복적으로 수행됨
  - 간접 사이클: 오퍼랜드 필드에 메모리 주소가 명시된 경우 추가 메모리 접근이 필요할 때 발생
- 일부 명령어는 인출-실행만, 다른 명령어는 인출-간접-실행 사이클을 모두 거침
- 인터럽트 사이클: 인터럽트를 처리하는 단계 (추가 학습 예정)
